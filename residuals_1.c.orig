/************************************************************************
* "residuals1.c"
*
* To compute the residuals of measurements of binary stars
* from known orbits.
*
* From o-c.for (version of 2008)
* written by Marco SCARDIA - Osservatorio Astronomico di Brera-Merate
*
* New features:
* - It is no longer necessary to indicate the number of objects
*   in the first line.
* - A line starting with % is interpreted as comments, and not
*   processed by the program.
* - Automatic precession correction of the input measurements
*   when the equinox of the orbit is very old (> 10 years)
* - It uses the catalog file "zeiss_doppie.cat" to retrieve 
*   the star coordinates, 
*   that are needed to compute the precession correction.
* - It can retrieve PISCO measurements from the output LaTeX table 
*   created by latex_calib or any other LaTeX table in this format
* - It can read orbits from a subset of the OC6 catalog.
*
* JLP 
* Version 08/04/2009
*************************************************************************/
#include <stdio.h>
#include <string.h>
#include <ctype.h>                   /* isprint... */
#include <math.h>
#include <time.h>                    /* date */

#define ABS(a) ((a) < 0.0  ? (-(a)) : (a))
#ifndef PI
#define PI 3.14159265
#endif
#define DEGTORAD   (PI/180.00)


#define DEBUG
#define DEBUG_1
/*
*/

int residuals1_main(char* input_filename, char *output_ext, 
                    char *calib_fname, int iformat);
int compute_residuals(FILE *fp_in, FILE *fp_out_txt, FILE *fp_out_latex, 
                      FILE *fp_out_curve, char *calib_fname, int iformat);
int compute_ephemerid(float Omega_node, float omega_peri, float i_incl,
                      float e_eccent, float T_periastron, float Period, 
                      float a_smaxis, float mean_motion, float epoch_o, 
                      float c_tolerance, float *theta_c, float *rho_c);
int precession_correction(float *dtheta_precess, float alpha, float delta, 
                          float epoch_o, float orbit_equinox);
static int get_orbit_from_Marco(char *line_buffer, FILE *fp_in, 
              char *calib_fname, int *iline, 
              int iformat, char *object_name, char *WDS_name, char *ADS_name, 
              char *discov_name, char *comp_name, char *author,
              float *Omega_node, float *omega_peri, float *i_incl, 
              float *e_eccent, float *T_periastron, float *Period, 
              float *a_smaxis, float *mean_motion, float *orbit_equinox);
static int get_measures_from_file(char *line_buffer, FILE *fp_in, int *iline, 
                                  float *epoch_o, float *rho_o, 
                                  float *theta_o, float *err_rho_o, 
                                  float *err_theta_o, int *nmeas);
int get_measures_from_Latex_table(char *calib_fname, char *object_name,
                                 char *comp_name,
                                 float *epoch_o, float *rho_o, float *theta_o,
                                 float *err_rho_o, float *err_theta_o, 
                                 int *nmeas);
int read_measures_from_line_of_Latex_table(char *line_buffer, float *epoch, 
                                           float *rho, float *err_rho,
                                           float *theta, float *err_theta);
static int get_orbit_from_OC6(char *line_buffer, FILE *fp_in, 
              char *calib_fname, int *iline, 
              int iformat, char *object_name, char *WDS_name, char *ADS_name, 
              char *discov_name, char *comp_name, char *author,
              float *Omega_node, float *omega_peri, float *i_incl, 
              float *e_eccent, float *T_periastron, float *Period, 
              float *a_smaxis, float *mean_motion, float *orbit_equinox);
static int process_measurements(FILE *fp_out_txt, FILE *fp_out_latex,
              FILE *fp_out_curve, char *catalog_name, char *object_name, 
              char *discov_name, char *comp_name, char *author,
              float Omega_node, float omega_peri, float i_incl, float e_eccent,
              float T_periastron, float Period, float a_smaxis, 
              float mean_motion, float orbit_equinox, float *epoch_o, 
              float *rho_o, float *theta_o, float *err_rho_o, 
              float *err_theta_o, int nmeas);
static int trim_string(char *str1, int len1);
static int is_in_line(char *line_buffer2, char *str1);
static int read_coordinates(char *line_buffer, float *alpha, float *delta,
                            float *coord_equinox);
static int read_object_name1(char *line_buffer, char *object_name, 
                             char *WDS_name, char *ADS_name, char *discov_name,
                             char *comp_name, char *author, int iline);
int latex_get_column_item(char *line_buffer, char *item, int icol);
int get_coordinates_from_catalog(char *catalog_name, char *object_name, 
                                 float *alpha, float *delta, 
                                 float *coord_equinox, int *has_an_orbit, 
                                 char *discov_name, char *comp_name);

int main(int argc, char *argv[])
{
char input_filename[80], output_ext[40], calib_fname[80];
int iformat;

if(argc == 7) {
  if(*argv[6]) argc = 7;
  else if(*argv[5]) argc = 6;
  else if(*argv[4]) argc = 5;
  else if(*argv[3]) argc = 4;
  else if(*argv[2]) argc = 3;
  else if(*argv[1]) argc = 2;
  else argc = 1;
}
if(argc != 4 && argc != 5) {
  printf("Syntax: residuals_1 input_list input_format output_ext [calibrated_latex_table]\n");
  printf("Format: -1 if Marco's format (Omega=node, omep=longitude of periastron, i, e, T, P, a, [equinox]) with measures\n");
  printf("        1 if Marco's format without measures\n");
  printf("        2 if OC6 format (P, a, i, Omega, T, e, omep, [equinox] )\n");
  return(-1);
}
strcpy(input_filename, argv[1]);
sscanf(argv[2], "%d", &iformat);
strcpy(output_ext, argv[3]);
/* Calibrated latex table (not necessary if iformat < 0) */
if(argc == 5) {
strcpy(calib_fname, argv[4]);
} else {
calib_fname[0] = '\0';
}
/* Error messages: */
if((iformat > 0) && (calib_fname[0] == '\0')) {
  fprintf(stderr, "iformat=%d: Calibrated table is needed: please provide filename\n",
          iformat);
  return(-1);
  }
#ifdef DEBUG
printf("OK: input=%s iformat=%d output_ext=%s calib_fname=%s\n", 
       input_filename, iformat, output_ext, calib_fname);
#endif

/* Call residuals1_main that does the main job: */
residuals1_main(input_filename, output_ext, calib_fname, iformat);

return(0);
}
/************************************************************************
* residuals1_main
* main routine of "residuals_1.c"
* Open the input/output files needed to compute the residuals 
* and call all other routines.
*
* INPUT:
* input_filename: name of the file containing the measurements and the
*                 orbital elements
* output_ext: extension of the output files
* calib_fname: name of the file containing the Latex calibrated table
*              (final version, ready for publication)
* iformat: format of the input file (-1=Marco with measures, 
*          1=Marco without measures, 2=OC6 without measures)
*
*************************************************************************/
int residuals1_main(char* input_filename, char *output_ext, 
                    char *calib_fname, int iformat)
{
char out_filename[100];
FILE *fp_in, *fp_out_txt, *fp_out_latex, *fp_out_curve;
time_t t = time(NULL);

fp_out_curve = NULL;

/* Open input file containing the measurements and the orbital parameters: */
if((fp_in = fopen(input_filename, "r")) == NULL) {
   fprintf(stderr, "residuals1_main/Fatal error opening input file: %s\n",
           input_filename);
    return(-1);
  }

/* Open output curve for O-C plot: */
  sprintf(out_filename, "%s_curve.dat", output_ext);
  if((fp_out_curve = fopen(out_filename, "w")) == NULL) {
    fprintf(stderr, "residuals1_main/Fatal error opening output calibrated latex file: %s\n",
           out_filename);
    return(-1);
   }

/* Open output ASCII text file in plain format: */
sprintf(out_filename, "%s.txt", output_ext);
if((fp_out_txt = fopen(out_filename, "w")) == NULL) {
   fprintf(stderr, "residuals1_main/Fatal error opening output text file: %s\n",
           out_filename);
    return(-1);
  }
fprintf(fp_out_txt, "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n");
fprintf(fp_out_txt, "%% Residuals from: %s, computed on %s", 
        input_filename, ctime(&t));
fprintf(fp_out_txt, "%% Created by residuals_1.c -- JLP version of 06/04/2009 --\n%% \n");
fprintf(fp_out_txt, "%% Name  Epoch  rho_O  rho_C  Drho_O-C  theta_O  theta_C  Dtheta_O-C  Author\n");
fprintf(fp_out_txt, "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n");

/* Open output Latex file: */
sprintf(out_filename, "%s.tex", output_ext);
if((fp_out_latex = fopen(out_filename, "w")) == NULL) {
   fprintf(stderr, "Compute_residuals/Fatal error opening output Latex file: %s\n",
           out_filename);
    return(-1);
  }

/* Header of the Latex table: */
fprintf(fp_out_latex, "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n");
fprintf(fp_out_latex, "%% Residuals from: %s, computed on %s", 
        input_filename, ctime(&t));
fprintf(fp_out_latex, "%% Created by residuals_1.c -- JLP version of 06/04/2009 --\n");
fprintf(fp_out_latex, "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n");
fprintf(fp_out_latex, "\\begin{table} \n\\begin{center} \n\
\\caption{Residuals of the measurements of Table 1 with published orbits.} \n\
\\begin{tabular}{llccrr} \n \\hline \n\
 ADS/Name  &   Orbit   & Epoch  & $\\rho$(O) \n\
& $\\Delta \\rho$(O-C) & $\\Delta \\theta$(O-C) \\\\ \n\
\\hline \n & & & & & \\\\ \n");

/* Header of the output curve: */
fprintf(fp_out_curve, "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n");
fprintf(fp_out_curve, "%% Residuals from: %s, computed on %s", 
        input_filename, ctime(&t));
fprintf(fp_out_curve, "%% Created by residuals_1.c -- JLP version of 06/04/2009 --\n");
fprintf(fp_out_curve, "%% Drho(O-C) Dtheta(O-C) err_rho_O err_theta_O\n");
fprintf(fp_out_curve, "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n");

/* Scan the input file and compute the residuals 
*/
compute_residuals(fp_in, fp_out_txt, fp_out_latex, fp_out_curve, 
                  calib_fname, iformat);

/* Epilog for Latex file: */
fprintf(fp_out_latex, " & & & & & \\\\ \n \\hline \n \\end{tabular} \n\
\\end{center} \n \\end{table*} \n");

/* Close opened files:
*/
fclose(fp_in);
fclose(fp_out_txt);
fclose(fp_out_latex);
if(fp_out_curve) fclose(fp_out_curve);
return(0);
}

/************************************************************************
* compute_residuals
* Scan the input file and compute the residuals 
*
* INPUT:
* fp_in: pointer to the input file containing the measurements and the
*        orbital elements
* fp_out_txt: pointer to the output file with the residuals and various data 
*             in plain ASCII format 
* fp_out_latex: pointer to the output Latex file with the residuals
* fp_out_curve: pointer to the file containing the O-C curve
* iformat: format of the input file (-1=Marco with measures, 
*          1=Marco without measures, 2=OC6 without measures)
*
*************************************************************************/
int compute_residuals(FILE *fp_in, FILE *fp_out_txt, FILE *fp_out_latex, 
                      FILE *fp_out_curve, char *calib_fname, int iformat)
{
float Omega_node, omega_peri, i_incl, e_eccent, T_periastron, orbit_equinox;
float mean_motion, a_smaxis, Period; 
float epoch_o[50], rho_o[50], theta_o[50], err_rho_o[50], err_theta_o[50];
int nmeas, i, iline, status;
char object_name[60], discov_name[40], comp_name[10], WDS_name[40]; 
char ADS_name[40], author[60], catalog_name[80];
/* Maximum line seems to be 265 for OC6 catalog... */
char line_buffer[300], *pc;

strcpy(catalog_name, "zeiss_doppie.cat");
iline = 0;
while(!feof(fp_in)) {
  if(fgets(line_buffer,300,fp_in)) {
    iline++;
    if(line_buffer[0] != '%') {
/* Check if very short line (such as the one with n_orbits, used by Marco's
* program
*/
    pc = line_buffer;
    i = 0;
    while(*pc) {i++; pc++;}
    if(i < 10) {
      printf("WARNING line #%d is very short (length=%d): >%s<\n", 
              iline, i, line_buffer);
    } else {
/* Read input line and retrieve the orbital parameters and the
*  measurements
*/
/* Marco Scardia's format: */
     if(ABS(iformat) == 1) 
     status = get_orbit_from_Marco(line_buffer, fp_in, 
                               calib_fname, &iline, iformat, object_name, 
                               WDS_name, ADS_name, discov_name, comp_name, 
                               author, &Omega_node, &omega_peri, &i_incl, 
                               &e_eccent, &T_periastron, &Period, &a_smaxis, 
                               &mean_motion, &orbit_equinox);
/* OC6 format: */
     else
     status = get_orbit_from_OC6(line_buffer, fp_in,
                                 calib_fname, &iline, iformat, object_name, 
                                 WDS_name, ADS_name, discov_name, comp_name, 
                                 author, &Omega_node, &omega_peri, &i_incl, 
                                 &e_eccent, &T_periastron, &Period, &a_smaxis, 
                                 &mean_motion, &orbit_equinox);
     if(status) {
     fprintf(stderr, "Fatal error processing line #%d\n", iline); 
     return(-1);
     }
/* Retrieve the measurements from the input file (if iformat < 0)
* or retrieve the measurements from the calibrated table.
*/
     if(iformat > 0) {
/* Read the measurements from the calibrated file if iformat > 0: */
      status = get_measures_from_Latex_table(calib_fname, object_name, 
                                             comp_name, epoch_o, rho_o, 
                                             theta_o, err_rho_o, 
                                             err_theta_o, &nmeas); 
/* Otherwise read the measurements from the input file fp_in: */
     } else {
       status = get_measures_from_file(line_buffer, fp_in, &iline, epoch_o, 
                                       rho_o, theta_o, err_rho_o, err_theta_o,
                                       &nmeas);
     }
     if(status) {
     fprintf(stderr, "Fatal error processing line #%d\n", iline); 
     return(-1);
     }
/* Process all measurements relative to a given object:
* correct the measurements from precession, compute the ephemerides,
* and derive the O-C residuals
*/
     status = process_measurements(fp_out_txt, fp_out_latex, fp_out_curve, 
                                   catalog_name, object_name, discov_name, 
                                   comp_name, author, Omega_node, omega_peri, 
                                   i_incl, e_eccent, T_periastron, Period, 
                                   a_smaxis, mean_motion, orbit_equinox, 
                                   epoch_o, rho_o, theta_o, err_rho_o, 
                                   err_theta_o, nmeas);
     if(status) {
     fprintf(stderr, "Fatal error processing measurements \n"); 
     return(-1);
     }
    } /* EOF line is short (i.e., i < 10) */
    } /* EOF if line_buffer != % */
  } /* EOF if fgets */ 
 }
printf("Compute_residuals: %d lines sucessfully read\n", iline);
return(0);
}
/***************************************************************************
* get_orbit_from_OC6
* Read input line and retrieve the orbital parameters and the measurements
* in OC6 ("Sixth Orbital Catalog") format (i.e., iformat = 2 or -2)
*
* Input lines contain
*  - name of object and orbital parameters in OC6 format (if iformat = 2 or -2) 
*  - the measurements (if iformat = -2)
*    otherwise, (if format = 2) retrieve the measurements 
*      from the calibrated table.
*
* Example:
*
* With iformat = 2:
*
* 000000.00+000000.0 00093+7943 STF   2          102    431    760   6.68   6.89    540.      y    .         0.995  a   .      110.1       .     171.2        .      1887.5     y    .       0.715     .       333.7       .  
   2000      3 n Hei1997  abcdefghikj.png
*
*
* INPUT:
* fp_in: pointer to the input file containing the measurements and the
*        orbital elements
* iformat: format of the input file (-1=Marco with measures, 
*          1=Marco without measures, 2=OC6 without measures)
* 
* OUTPUT:
* object designation, orbital parameters and arrays with the measurements
*
***************************************************************************/
static int get_orbit_from_OC6(char *line_buffer, FILE *fp_in, 
              char *calib_fname, int *iline, 
              int iformat, char *object_name, char *WDS_name, char *ADS_name, 
              char *discov_name, char *comp_name, char *author,
              float *Omega_node, float *omega_peri, float *i_incl, 
              float *e_eccent, float *T_periastron, float *Period, 
              float *a_smaxis, float *mean_motion, float *orbit_equinox)
{
char buffer[80];

printf("OKK:%s", line_buffer);
/* Retrieve the object designation and the author of the orbit
*/
strncpy(WDS_name, &line_buffer[19], 10);
WDS_name[10] = '\0';

strncpy(discov_name, &line_buffer[30], 7);
discov_name[7] = '\0';

strncpy(comp_name, &line_buffer[37], 7);
comp_name[7] = '\0';
trim_string(comp_name, 10);

strncpy(ADS_name, &line_buffer[45], 5);
ADS_name[5] = '\0';
trim_string(ADS_name, 40);

/* Period: */
strncpy(buffer, &line_buffer[81], 11);
buffer[11] = '\0';
if(sscanf(buffer, "%f", Period) != 1) {
  fprintf(stderr, "Error reading period: buffer=%s\n", buffer);
  return(-1);
  }
/* Units: days, centuries, or years */
if(line_buffer[92] == 'd') 
  *Period /= 365.25;
else if(line_buffer[92] == 'c') 
  *Period *= 100.;
else if(line_buffer[92] != 'y') 
  {
  fprintf(stderr, "Error reading period: unknown unit (P=%.20s unit=%c)\n", 
          &line_buffer[81], line_buffer[92]);
  return(-1);
  }

/* Semi-major axis: */
strncpy(buffer, &line_buffer[105], 9);
buffer[9] = '\0';
if(sscanf(buffer, "%f", a_smaxis) != 1) {
  fprintf(stderr, "Error reading semi-major axis: buffer=%s\n", buffer);
  return(-1);
  }
/* Units: milliarcseconds or arcseconds */
if(line_buffer[114] == 'm') 
  *a_smaxis *= 1000.;
else if(line_buffer[114] != 'a') 
  {
  fprintf(stderr, "Error reading semi-major axis: unknown unit (a=%.20s unit=%c)\n", 
          &line_buffer[105], line_buffer[114]);
  return(-1);
  }

/* Inclination (degrees) */
strncpy(buffer, &line_buffer[125], 8);
buffer[8] = '\0';
if(sscanf(buffer, "%f", i_incl) != 1) {
  fprintf(stderr, "Error reading inclination: buffer=%s\n", buffer);
  return(-1);
  }

/* Node, Omega (degrees) */
strncpy(buffer, &line_buffer[143], 8);
buffer[8] = '\0';
if(sscanf(buffer, "%f", Omega_node) != 1) {
  fprintf(stderr, "Error reading Omega (node): buffer=%s\n", buffer);
  return(-1);
  }

/* T of periastron passage */
strncpy(buffer, &line_buffer[162], 12);
buffer[12] = '\0';
if(sscanf(buffer, "%f", T_periastron) != 1) {
  fprintf(stderr, "Error reading T periastron: buffer=%s\n", buffer);
  return(-1);
  }
/* Units: Julian days or Besselian years */
if(line_buffer[174] == 'd') 
  {
  fprintf(stderr, "Error reading period: Julian days are not allowed (%.20s unit=%c)\n", 
          &line_buffer[162], line_buffer[174]);
  return(-1);
  }
else if(line_buffer[174] != 'y') 
  {
  fprintf(stderr, "Error reading period: unknown unit (P=%.20s unit=%c)\n", 
          &line_buffer[162], line_buffer[174]);
  return(-1);
  }

/* Eccentricity */
strncpy(buffer, &line_buffer[187], 8);
buffer[8] = '\0';
if(sscanf(buffer, "%f", e_eccent) != 1) {
  fprintf(stderr, "Error reading eccentricity: buffer=%s\n", buffer);
  return(-1);
  }

/* omega (longitude of periastron) */
strncpy(buffer, &line_buffer[205], 8);
buffer[8] = '\0';
if(sscanf(buffer, "%f", omega_peri) != 1) {
  fprintf(stderr, "Error reading omega_periastron: buffer=%s\n", buffer);
  return(-1);
  }

/* Equinox */
strncpy(buffer, &line_buffer[223], 4);
buffer[4] = '\0';
/* Default value is 2000.0 */
if(sscanf(buffer, "%f", orbit_equinox) != 1) {
  *orbit_equinox = 2000.0;
}

/* Reference of orbit (author) */
strncpy(author, &line_buffer[237], 8);
author[8] = '\0';
trim_string(author, 60);

/* Restriction of the object name to ADS name or discoverer name */
if(ADS_name[0] != '\0') sprintf(object_name, "ADS %s", ADS_name);
else if (discov_name[0] != '\0') strcpy(object_name, discov_name);

#ifdef DEBUG_1
printf("Object=%s WDS=%s ADS=%s discov=%s comp=%s author=%s\n",
        object_name, WDS_name, ADS_name, discov_name, comp_name, author);

 printf("Omega_node=%.3f omega_peri=%.3f incl=%.3f e=%.4f T=%.3f P=%.3f a=%.5f Equinox=%.3f\n", 
        *Omega_node, *omega_peri, *i_incl, *e_eccent, *T_periastron, 
        *Period, *a_smaxis, *orbit_equinox);
#endif

/* Conversion to radians: */
 *Omega_node *= DEGTORAD;
 *omega_peri *= DEGTORAD;
 *i_incl *= DEGTORAD;
 *mean_motion = (360.0 / *Period) * DEGTORAD;

return(0);
}
/***************************************************************************
* get_measures_from_file
* Retrieve the measurements from the input file (when iformat < 0)
*
* Examples:
*
* 2007.969 0.656 155.3 1
* 2007.969 0.653 154.4 0
*
* or:
*
* 2007.9693 0.825 18.0 0
*
* INPUT:
* fp_in: pointer to the input file containing the measurements and the
*        orbital elements
* 
* OUTPUT:
* object designation, orbital parameters and arrays with the measurements
*
***************************************************************************/
static int get_measures_from_file(char *line_buffer, FILE *fp_in, int *iline, 
                                  float *epoch_o, float *rho_o, 
                                  float *theta_o, float *err_rho_o, 
                                  float *err_theta_o, int *nmeas)
{
float epoch, rho, theta;
int kk, nval;

/* Read the measurements from the input file if iformat < 0: */
   *nmeas = 0;
   do {
   line_buffer[0] = '%';
   while(!feof(fp_in) && line_buffer[0] == '%') {
    (*iline)++;
    if(!fgets(line_buffer,300,fp_in)) {
    fprintf(stderr, "Process_new_orbit/Fatal error reading input file at line #%d \n %s \n", 
            *iline, line_buffer);
    return(-2);
    }
   } 

   nval = sscanf(line_buffer, "%f %f %f %d", &epoch, &rho, &theta, &kk);
   if(nval != 4) {
    fprintf(stderr, "Process_new_orbit/Fatal error reading input file at line #%d \n %s \n", 
            *iline, line_buffer);
    return(-2);
    }
    epoch_o[*nmeas] = epoch;
    rho_o[*nmeas] = rho;
    theta_o[*nmeas] = theta;
    err_rho_o[*nmeas] = 0.;
    err_theta_o[*nmeas] = 0.;
    (*nmeas)++;

#ifdef DEBUG_1
   printf("iline=%d/measurements: %f %f %f %d\n", 
           *iline, epoch, rho, theta, kk);
#endif
  } while(kk == 1); /* EOF while kk == 1 */

return(0);
}
/***************************************************************************
* get_orbit_from_Marco 
* Read input line and retrieve the orbital parameters and the measurements
* in Marco's format (i.e., iformat = 1 or -1)
*
* Input lines contain
*  - name of object 
*  - the orbital parameters in Marco's format (if iformat = 1 or -1) 
*  - the measurements (if iformat = -1)
*    otherwise, (if format = 1) retrieve the measurements 
*      from the calibrated table.
*
* Examples:
*
* With iformat = -1:
*
* ADS 293 - Ole2001
* 149.0 182.7 128.3 0.9424 1928.76 335.385 0.3935 
* 2007.969 0.656 155.3 1
* 2007.969 0.653 154.4 0
*
* or:
*
* 00093+7943 STF   2 = ADS 102 - Hei1997 - Heintz (1997)
* 171.2 333.7 110.1 0.715 1887.5 540.0 0.995
* 2007.9693 0.825 18.0 0
*
* With iformat = 1:
*
* ADS 293 - Ole2001
* 149.0 182.7 128.3 0.9424 1928.76 335.385 0.3935 
*
* INPUT:
* fp_in: pointer to the input file containing the measurements and the
*        orbital elements
* iformat: format of the input file (-1=Marco with measures, 
*          1=Marco without measures, 2=OC6 without measures)
* 
* OUTPUT:
* object designation, orbital parameters and arrays with the measurements
*
***************************************************************************/
static int get_orbit_from_Marco(char *line_buffer, FILE *fp_in, 
              char *calib_fname, int *iline, 
              int iformat, char *object_name, char *WDS_name, char *ADS_name, 
              char *discov_name, char *comp_name, char *author,
              float *Omega_node, float *omega_peri, float *i_incl, 
              float *e_eccent, float *T_periastron, float *Period, 
              float *a_smaxis, float *mean_motion, float *orbit_equinox)
{
int nval, status;

/* Decode the first line containing the object designation
* and the author of the orbit
*/
status = read_object_name1(line_buffer, object_name, WDS_name, ADS_name, 
                          discov_name, comp_name, author, *iline);

/* Read next line: */
while(!feof(fp_in)) {
  if(fgets(line_buffer,300,fp_in)) {
    (*iline)++;
    if(line_buffer[0] != '%') break; 
  }
}

/* Read orbital elements from input file: */
/* Marco's format, i.e., iformat = -1 or iformat = 1 */
 nval = sscanf(line_buffer, "%f %f %f %f %f %f %f %f", 
                Omega_node, omega_peri, i_incl, e_eccent, T_periastron, 
                Period, a_smaxis, orbit_equinox);
 if(nval != 7 && nval != 8) {
  fprintf(stderr, "Process_new_orbit/Fatal error reading input file at line #%d (nval=%d) \n %s \n", 
          *iline, nval, line_buffer);
  return(-2);
  }
 if(nval == 7) *orbit_equinox = 2000.0;

#ifdef DEBUG_1
 printf("nval=%d Omega_node=%f omega_peri=%f incl=%f e=%f T=%f P=%f a=%f Equinox=%f\n", 
        nval, *Omega_node, *omega_peri, *i_incl, *e_eccent, *T_periastron, 
        *Period, *a_smaxis, *orbit_equinox);
#endif

/* Conversion to radians: */
 *Omega_node *= DEGTORAD;
 *omega_peri *= DEGTORAD;
 *i_incl *= DEGTORAD;
 *mean_motion = (360.0 / *Period) * DEGTORAD;

return(0);
}
/************************************************************************
* Process all measurements relative to a given object:
* correct the measurements from precession, compute the ephemerides,
* and derive the O-C residuals
*
* INPUT:
* fp_out_txt: pointer to the output file with the residuals and various data 
*             in plain ASCII format 
* fp_out_latex: pointer to the output Latex file with the residuals
* fp_out_curve: pointer to the output file containing the O-C curve 
* catalog_name: name of the catalog ("zeiss_doppie.cat") used
*               for retrieving the object coordinates
*
* OUTPUT:
* O-C residuals in "fp_out_txt" and "fp_out_latex" files
************************************************************************/
static int process_measurements(FILE *fp_out_txt, FILE *fp_out_latex,
              FILE *fp_out_curve, char *catalog_name, char *object_name, 
              char *discov_name, char *comp_name, char *author,
              float Omega_node, float omega_peri, float i_incl, float e_eccent,
              float T_periastron, float Period, float a_smaxis, 
              float mean_motion, float orbit_equinox, float *epoch_o, 
              float *rho_o, float *theta_o, float *err_rho_o, 
              float *err_theta_o, int nmeas)
{
char discov_name0[40], comp_name0[40], my_name[60];
float alpha, delta, dtheta_precess, coord_equinox, c_tolerance;
float rho_c, theta_c, Drho, Dtheta;
int status, has_an_orbit;
register int i;

/*  c_tolerance = smallest increment allowed in the iterative process
*                used for solving Kepler's equation
*/
c_tolerance = ABS(1.5E-5 * cos(i_incl) 
                   / sqrt((1.0 + e_eccent)/(1.0 - e_eccent)));

/* Main loop on all the measures 
*/
for(i = 0; i < nmeas; i++) {
/* Conversion to radians: */
 theta_o[i] *= DEGTORAD;

/* Correction for precession if equinox is distant from observation epoch: */
/* DEBUGGG */
if(ABS(epoch_o[i] - orbit_equinox) > 10.){
/* Look for object_name in file catalog_name ("zeiss_doppie.cat"), 
* and determine values of: alpha, delat, coord_equinox,
*                          has_an_orbit, discov_name0, comp_name0.
*/
status = get_coordinates_from_catalog(catalog_name, object_name, 
                                      &alpha, &delta, &coord_equinox, 
                                      &has_an_orbit, discov_name0, comp_name0);
printf("Correction for precession for object %s (equinox=%.3f)\n", 
        object_name, orbit_equinox);
/* Compute dtheta_precess, the precession correction:
*/
if(!status) {
  precession_correction(&dtheta_precess, alpha, delta, epoch_o[i], 
                        orbit_equinox);
  fprintf(fp_out_txt, "%% %s: measures corrected for precession (equinox=%.1f): dtheta=%.3f (deg)\n",
          object_name, orbit_equinox, dtheta_precess / DEGTORAD);
/* Apply the correction to theta (in radians): */
#ifdef DEBUG
  printf(" %s: measures corrected for precession (equinox=%.1f): theta_o = %.3f dtheta=%.3f theta_o_corrected=%.3f\n",
          object_name, orbit_equinox, theta_o[i] / DEGTORAD, 
          dtheta_precess / DEGTORAD, (theta_o[i] + dtheta_precess) / DEGTORAD);
#endif
/* Apply the correction to theta (in radians): */
  theta_o[i] += dtheta_precess;
} else { 
  fprintf(stderr, "Fatal error/Object >%s< not found in catalog\n", object_name);
  return(-1);
} /* EOF status != 0*/
} /* EOF ABS(epoch_o - orbit_equinox) > 10.) */

/* Compute the ephemerids corresponding to the observation epoch: */
compute_ephemerid(Omega_node, omega_peri, i_incl, e_eccent, T_periastron, 
                  Period, a_smaxis, mean_motion, epoch_o[i], c_tolerance, 
                  &theta_c, &rho_c);

/* Conversion to degrees: */
 theta_o[i] /= DEGTORAD;
 theta_c /= DEGTORAD;
 Dtheta = theta_o[i] - theta_c;
 if(Dtheta < -300.0) Dtheta += 360.0;
 if(Dtheta > 300.0) Dtheta -= 360.0;

 Drho = rho_o[i] - rho_c;
/* Trick to have a constant width */
 sprintf(my_name, "%s %s", object_name, comp_name);
/* Left justified text is obtained with a minus sign in the format:*/
 fprintf(fp_out_txt, "%-18.18s %9.3f %9.3f %9.3f %8.2f %8.2f %8.2f %7.1f %s\n",
         my_name, epoch_o[i], rho_o[i], rho_c, Drho, theta_o[i], theta_c, 
         Dtheta, author);
 fprintf(fp_out_latex, "%s %s & %s & %9.3f & %9.3f & %8.2f & %8.2f \\\\\n",
         object_name, comp_name, author, epoch_o[i], rho_o[i], Drho, Dtheta);
 fprintf(fp_out_curve, "%8.3f %7.2f %8.3f %7.2f %9.3f %-18.18s %s \n",
         Drho, Dtheta, err_rho_o[i], err_theta_o[i], epoch_o[i], my_name, author);
}

return(0);
}
/***************************************************************************
* Read object name in Marco or Luigi's format
*
* Example of input lines:
* 15348+1032 STF1954AB = ADS 9701 - WSI2004a - Mason et al. (2004a)
* 15278+2906 JEF   1 - Tok1984 - Tokovinin (1984)
* or
* ADS 504 - Nov2008a
* JEF   1 - Tok1984
*
****************************************************************************/
static int read_object_name1(char *line, char *object_name, char *WDS_name,
                             char *ADS_name, char *discov_name, char *comp_name,
                             char *author, int iline)
{
char *pc1, buffer[80];
int i, j, idash, iwds, nval;

/* ADS 11635Cc-D - Doc1984b
*/
 strncpy(object_name, line, 40);
 idash = 0;
 for(i = 0; i < 39 && object_name[i]; i++) {
   if(object_name[i] == ' ' && object_name[i+1] == '-') {
     idash = i+1;
     break;
     }
   }
object_name[i] = '\0';

if(idash <= 0) {
  fprintf(stderr, "Process_new_orbit/Bad syntax of object name in line #%d\n (%s)\n", 
          iline, line);
  return(-1);
  }

/* Remove the extra-blanks: */
trim_string(object_name, 40);

/* WDS_name (e.g., 15278+2906) */
WDS_name[0] = '\0';
iwds = 0;
if(object_name[5] == '+' || object_name[5] == '-') {
 nval = sscanf(object_name, "%05d%05d", &i, &j);
 if(nval == 2) { 
   strncpy(WDS_name, object_name, 10); 
   WDS_name[10] = '\0';
   iwds = 10;
   }
 }

/* Discover name:  (e.g. JEF  2 AB) */
strcpy(buffer, &object_name[iwds]);
pc1 = buffer;
i = 0;
while(*pc1  && strncmp(pc1, "ADS", 3) && *pc1 != '=') 
      discov_name[i++] = *(pc1++);
discov_name[i] = '\0';
/* Remove the extra-blanks: */
trim_string(discov_name, 40);

/* Compagnon name (AB, Aa, BC, etc) from discover name 
* (after the numbers) */
comp_name[0] = '\0';
if(*discov_name) {
  pc1 = &discov_name[0];
  while(*pc1  && (isalpha(*pc1) || *pc1 == ' ')) pc1++; 
  while(*pc1  && (isdigit(*pc1) || *pc1 == ' ')) pc1++; 
  strcpy(comp_name, pc1);
  *pc1 = '\0';
}

/* ADS name: */
strcpy(buffer, object_name);
pc1 = buffer;
while(*pc1  && strncmp(pc1, "ADS", 3)) pc1++; 
if(!strncmp(pc1, "ADS", 3))
  strcpy(ADS_name, pc1);
else
  ADS_name[0] = '\0';

/* Remove the extra-blanks: */
trim_string(ADS_name, 40);

/* Compagnon name (AB, Aa, BC, etc) from ADS name 
* (after the numbers) */
if((comp_name[0] == '\0') && (ADS_name[0] != '\0')) {
  pc1 = &ADS_name[0];
  while(*pc1  && (isalpha(*pc1) || *pc1 == ' ')) pc1++; 
  while(*pc1  && (isdigit(*pc1) || *pc1 == ' ')) pc1++; 
  strcpy(comp_name, pc1);
  *pc1 = '\0';
}

/* Copy the author (removing the Carriage Return/EOF if present): */
i = 0;
pc1 = &line[idash + 1];
while(*pc1 && i < 59) {
   if(isprint(*pc1)) author[i++] = *pc1;
   pc1++;
   }
author[i] = '\0';

/* Remove the extra-blanks: */
trim_string(author, 60);

#ifdef DEBUG
printf("iline=%d\n object: >%s< author: >%s<\n", iline, object_name, author);
printf("WDS=%s, discov=%s, (comp=%s) ADS=%s. \n", 
        WDS_name, discov_name, comp_name, ADS_name);
#endif

/* Restriction of the object name to ADS name or discoverer name */
if(ADS_name[0] != '\0') strcpy(object_name, ADS_name);
else if (discov_name[0] != '\0') strcpy(object_name, discov_name);

return(0);
}
/*************************************************************
* Compute the ephemerids corresponding to the observation epoch: 
*
* INPUT:
*  Omega_node (radians), omega_peri (radians), i_incl (radians), 
*  e_eccent, T_periastron (years), Period (years),
*  a_smaxis (arcseconds) =  orbital elements
*  epoch_o = Epoch of the ephemerid
*  c_tolerance = smallest increment allowed in the iterative process
*                used for solving Kepler's equation
*
* OUTPUT:
*  theta_c = ANGOLO DI POSIZIONE CALCOLATO (radians)
*  rho_c= DISTANZA ANGOLARE CALCOLATA
*
**************************************************************/
int compute_ephemerid(float Omega_node, float omega_peri, float i_incl, 
                      float e_eccent, float T_periastron, float Period, 
                      float a_smaxis, float mean_motion, float epoch_o, 
                      float c_tolerance, float *theta_c, float *rho_c)
{
double daa, aa, ab, pp, theta;
double ee, eps, cc, mean_anomaly, eccentric_anomaly, true_anomaly;
/* mean_anomaly = ANOMALIA MEDIA
* true_anomaly = ANOMALIA VERA
* eccentric_anomaly = ANOMALIA ECCENTRICA
*/
   daa = epoch_o - T_periastron;
/*   mean_anomaly = mean_motion * AMOD(daa, Period);
* real function that returns the value of daa modulo Period
* i.e.:
*/
   daa = daa - Period * (float)((int)(daa / Period));
   mean_anomaly = mean_motion * daa;
/* Initialize ee: */
   ee = mean_anomaly + e_eccent*sin(mean_anomaly)
             / sqrt(1.0 + e_eccent * (e_eccent - 2.0 * cos(mean_anomaly)));
/* Iterative resolution of Kepler's equation: */
   do {
    eps = (mean_anomaly - ee) + e_eccent * sin(ee);
    cc = eps / (1.0 - e_eccent * cos(ee));
/* Correction of the current value of ee: */
    ee += cc;
   } while(ABS(cc) > c_tolerance);

   eccentric_anomaly = ee * 0.5;
   aa = sqrt((1.0 + e_eccent) / (1.0 - e_eccent)) * sin(eccentric_anomaly);
/* In FORTRAN: 
* ATAN2(y,x) returns the argument alpha of the complex number x + i y,
* expressed in radians, in the range [-PI, +PI],
* such that: tan(alpha) = y / x
* if x > 0  alpha = arctan(y/x)
* if x < 0  alpha = +PI + arctan(y/x) if y > 0
*       or  alpha = -PI + arctan(y/x) if y < 0
* if x = 0  alpha = PI/2 if y > 0 or alpha = -PI/2 if y < 0
*
* Same syntax in C: atan2(y,x) = arctan(y/x) = ATAN2(y,x) 
*/
   true_anomaly = 2.0 * atan2(aa, cos(eccentric_anomaly));
   pp = true_anomaly + omega_peri;
   if(pp > 2.*PI) pp -= 2.*PI;
   ab = cos(i_incl) * sin(pp);
   theta = atan2(ab, cos(pp));
   if(theta < 0.0) theta += 2.*PI;

/* Computed position angle: */
   *theta_c = theta + Omega_node;
   if(*theta_c > 2.*PI) *theta_c -= 2.*PI;

printf("theta=%f theta_c=%f\n", theta, *theta_c);
/* Computed separation angle: */
   *rho_c = a_smaxis * (1.0 - e_eccent * cos(ee)) * cos(pp) / cos(theta);
printf("pp=%f ee=%f e_ccent=%f a_smaxis=%f rho_c=%f\n", pp, ee, e_eccent,
       a_smaxis, *rho_c);

return(0);
}
/************************************************************************
* Removes the trailing blanks 
* and the extra-blanks (more than one successive blanks) contained in string
*
************************************************************************/
static int trim_string(char *str1, int len1)
{
char str1_copy[120];
char *pc1;
int i;

str1[len1 - 1] = '\0';

/* Remove the non printable characters (tab, eof line, cr, etc): */
pc1 = str1; 
i = 0;
while(*pc1) {
 if(isprint(*pc1)) str1_copy[i++] = *pc1;
 pc1++;
 }
str1_copy[i] = '\0';


/* Remove the first blanks: */
pc1 = str1_copy; 
while(*pc1 == ' ') pc1++;
strcpy(str1, pc1);

/* Remove the trailing blanks: */
pc1 = str1; 
i = 0;
while(*pc1) {pc1++; i++;}
i--;
while(i > 0 && str1[i] == ' ') str1[i--] = '\0';
strcpy(str1_copy, str1);
strcpy(str1, str1_copy);

/* Remove the contiguous blanks contained in string : */
pc1 = str1_copy;
for(i = 0; i < len1 && str1[i] != '\0'; i++)
  if(str1[i] != ' ' || str1_copy[i+1] != ' ') *(pc1++) = str1[i];
*pc1 = '\0';

strcpy(str1, str1_copy);

return (0);
}
/************************************************************
* Correction for precession
* using the formula of Armellini (1931) (or Couteau, 1978)
*
* INPUT : 
* theta: before correction (in radians)
* alpha, delta: coordinates of object (in radians)
* epoch_o: epoch of observation
* orbit_equinox: equinox used as a reference for computing the orbit 
*
* OUTPUT : 
* dtheta_precess: correction for precession (in radians)
*************************************************************/
int precession_correction(float *dtheta_precess, float alpha, float delta, 
                          float epoch_o, float orbit_equinox)
{

/* Precession correction of theta in arcseconds 
*/
  *dtheta_precess = -20.0 * (epoch_o - orbit_equinox) * sin(alpha) / cos(delta);

#ifdef DEBUG_1
  printf(" epoch=%f equinox=%f sin(alpha)=%f cos(delta)=%f\n", 
         epoch_o, orbit_equinox, sin(alpha), cos(delta));
  printf(" correction for precession: %f (arcsec) or %f (degrees)\n", 
         *dtheta_precess,  *dtheta_precess/3600.);
#endif

/* Conversion to radians: */
  *dtheta_precess *= DEGTORAD/3600.;

return(0);
}
/************************************************************
* Search for the coordinates of an object in the input file 
* whose name is catalog_name.
*
* INPUT : 
* object_name: name of object
* catalog_name: name of catalog ("zeiss_doppie.cat")
*
* OUTPUT : 
* alpha, delta: coordinates of object (in radians)
* epoch_o: epoch of observation
* coord_equinox: equinox corresponding to the coordinates 
* has_an_orbit: flag set to one if an orbit is present
* discov_name: name of this object as given by its discoverer 
* comp_name: name of the components (e.g., Aa, AB, AC, etc)
*
*************************************************************/
int get_coordinates_from_catalog(char *catalog_name, char *object_name, 
                                 float *alpha, float *delta, 
                                 float *coord_equinox, int *has_an_orbit, 
                                 char *discov_name, char *comp_name)
{
char line_buffer1[80], line_buffer2[80], *pc;
FILE *fp_cat;
int found, digit_found, object_len, status;

if((fp_cat = fopen(catalog_name, "r")) == NULL) {
  fprintf(stderr, "get_coordinates_from_catalog/Error opening %s\n", 
          catalog_name);
  return(-1);
 }

/* Compute the useful length of the object_name: 
* ADS 123AB should be 7 only 
* COU 12 Ac should be 6 only 
*/
pc = object_name;
object_len = 0;
digit_found = 0;
while(*pc) {
  if(isdigit(*pc)) digit_found = 1;
  if(!isdigit(*pc) && digit_found) break;
  pc++; 
  object_len++;
  }

/* Look for the data concerning this object: */
found = 0;
while(!feof(fp_cat)) {
  if(fgets(line_buffer1,80,fp_cat)) {
  if(line_buffer1[0] != '%') {
/* ADS 213 is sometimes written as: ADS 213AB
* but not as ADS 2136
*/
    if(!strncmp(line_buffer1, object_name, object_len) 
       && !isdigit(line_buffer1[object_len]) ){
       if(fgets(line_buffer2,80,fp_cat)) {
         found = 1;
         break;
         } else {
         fprintf(stderr, "Error reading second line of object data\n");
         break;
         }
     } /* EOF !strncmp(line_buffer1, object_name, object_len) */
   } /* EOF line_buffer1 != % */ 
 } /* EOF fgets */
} /* EOF while */

if(found) {
  status = read_coordinates(line_buffer1, alpha, delta, coord_equinox);
  if(status) {
    fprintf(stderr, "Error reading catalog at line: >%s< (status=%d)\n", 
            line_buffer1, status);
    } else {
    *has_an_orbit = is_in_line(line_buffer2, "orbit");
#ifdef DEBUG
    printf("object=%s object_len=%d orbit=%d alpha=%f delta=%f \n %s\n %s\n", 
           object_name, object_len, *has_an_orbit, *alpha, *delta, 
           line_buffer1, line_buffer2);
#endif
    status = 0;
    }
  } else {
  status = -1;
  }

/* Close catalog */
fclose(fp_cat);
return(status);
}
/*********************************************************************
* Check if str1 is contained in line_buffer1
*********************************************************************/
static int is_in_line(char *line_buffer1, char *str1)
{
int found;
char *pc;
pc = line_buffer1;
found = 0;
while(*pc && !found) {
  if(strncmp(str1, pc, strlen(str1))) found = 1;
  pc++;
}
return(found);
}
/*********************************************************************
* Read coordinates in catalog: 
* Syntax:
* name & 23 12 03.5 & -23 34 21 & 2000 
*
* INPUT:
* line_buffer: line containing the data
*
* OUTPUT:
* alpha, delta: coordinates of object
* coord_equinox: corresponding equinox
*********************************************************************/
static int read_coordinates(char *line_buffer, float *alpha, float *delta,
                            float *coord_equinox)
{
int a1, a2, d1, d2, nval, isign;
float a3, d3;
char *pc;

*alpha = 0.;
*delta = 0.;
*coord_equinox = 0.;

/* Skip the first column: */
pc = line_buffer;
while(*pc != '&' && *pc) pc++;
if(*pc == '\0') return(-1);

/* Read alpha in the 2nd column: */
pc++;
nval = sscanf(pc, "%d %d %f", &a1, &a2, &a3);
if(nval != 3) return(-2);

/* Conversion from hours to radians: */
*alpha = (a1 + (float)a2 / 60. + a3 / 3600.) * PI / 12.;

/* Moves to the 3rd column: */
while(*pc != '&' && *pc) pc++;
if(*pc == '\0') return(-3);

/* Read delta in the 3rd column: */

/* First detect the minus sign if present: */
pc++;
while(*pc == ' ') pc++;
isign = +1;
if(*pc == '-') {
  isign = -1;
  pc++;
} else if (*pc == '+') pc++;

nval = sscanf(pc, "%d %d %f", &d1, &d2, &d3);
if(nval != 3) return(-4);

/* Conversion from degrees to radians: */
*delta = isign * (d1 + (float)d2 / 60. + d3 / 3600.) * DEGTORAD;

/* Moves to the 4th column: */
while(*pc != '&' && *pc) pc++;
if(*pc == '\0') return(-5);

/* Read equinox in the 4th column: */
pc++;
nval = sscanf(pc, "%f", coord_equinox);
if(nval != 1) return(-6);

#ifdef DEBUG_1
printf("OK: alpha = %d %d %.2f (=%f radians)\n", a1, a2, a3, *alpha);
printf("delta = %d %d %.2f sign=%d (=%f radians)\n", d1, d2, d3, isign, *delta);
printf("equinox= %.2f\n", *coord_equinox);
#endif

return(0);
}
/***********************************************************************
* Retrieve the measurements from the calibrated table (when iformat > 0)
* and look for the measurements of a given object in the calibrated Latex table
*
* INPUT:
* object_name: name of object (either ADS 123 or COU 432)
*
* OUTPUT:
* epoch_o, rho_o (arcsec), theta_o (deg): observed measurements 
* err_rho_o (arcsec), err_theta_o (deg): errors of the observed measurements
* nmeas: number of measurements
***********************************************************************/
int get_measures_from_Latex_table(char *calib_fname, char *object_name,
                                  char *comp_name, float *epoch_o, 
                                  float *rho_o, float *theta_o,
                                  float *err_rho_o, float *err_theta_o, 
                                  int *nmeas)
{
char line_buffer[300], name1[40], name2[40], comp_name2[40];
char *pc1;
int icol, ifound, status, kk, iline, line_is_OK;
FILE *fp_latex_table;

/* Test the structure of the object name (either ADS 234 or COU 345, f.i.)
* Look for ADS name in the 3rd column*/
if(!strncmp(object_name, "ADS", 3)) {
    strcpy(name1, &object_name[3]);
    trim_string(name1, 40);
    icol = 3;
/* Else look for the discoverer name in the 2nd column*/
    } else {
    strcpy(name1, object_name);
    trim_string(name1, 40);
    icol = 2;
    }

/* Open LaTeX table: */
if((fp_latex_table = fopen(calib_fname, "r")) == NULL) {
  fprintf(stderr, "get_measures_from_Latex_table/Error opening %s\n", 
          calib_fname);
  return(-1);
 }

/* Scan all the file looking for the object name */ 
ifound = 0;
iline = 0;
while(!feof(fp_latex_table) && !ifound){
  if(fgets(line_buffer,300,fp_latex_table)) {
  iline++;
  if(line_buffer[0] != '%') {
    status = latex_get_column_item(line_buffer, name2, icol);
/* Process only the meaningful lines (skipping the header...)*/
    if(!status) {
      trim_string(name2, 40);
      if(!strcmp(name1, name2)) {
/* Then check that the components are the same: */
      if(comp_name[0] != '\0') {
/* Get discover name */
        status = latex_get_column_item(line_buffer, name2, 2);
/* Compagnon name (AB, Aa, BC, etc) from discover name 
* (after the numbers) */
        comp_name2[0] = '\0';
        if(*name2) {
          pc1 = &name2[0];
          while(*pc1  && (isalpha(*pc1) || *pc1 == ' ')) pc1++;
          while(*pc1  && (isdigit(*pc1) || *pc1 == ' ')) pc1++;
          strcpy(comp_name2, pc1);
          *pc1 = '\0';
        }
        if(!status) {
        trim_string(comp_name2, 40);
/* If component are the same, stop the search here */
        if(!strcmp(comp_name, comp_name2)) {
        ifound = 1;
        break;
        }
        } /* EOF status */
/* If no indication of component, stop the search here */
      } else {
        ifound = 1;
        break;
      }
    }
   } /* EOF !status */
  } /* EOF line_buffer[0] != '%' */
  } /* EOF fgets() */
} /* EOF while */

status = -1;
*nmeas = 0;
if(ifound) {
/* Do while line_is_OK: */
kk = 0;
do {
status = read_measures_from_line_of_Latex_table(line_buffer, &epoch_o[kk],
                                           &rho_o[kk], &err_rho_o[kk],
                                           &theta_o[kk], &err_theta_o[kk]);
printf("Object found: name1=%s %s (kk=%d) rho=%.3f (+/-%.3f) theta=%.2f (+/-%.2f) epoch=%.3f \n",
       name1, comp_name, kk, rho_o[kk], err_rho_o[kk], theta_o[kk], err_theta_o[kk], 
       epoch_o[kk]);
printf(">%s<\n", line_buffer);

/* Go to next line and check if there are other measurements of the same object:
*/
  line_is_OK = 0;
  if(fgets(line_buffer,300,fp_latex_table)) {
   if(!strncmp(line_buffer, "\\idem", 5)) line_is_OK = 1;
   } 
/* Increment kk for next iteration: */
  kk++;
  } while (line_is_OK);
/* Number of measurements: */
*nmeas = kk;
printf("nmeas = %d\n", *nmeas);
/* EOF if (found) */
} else {
printf("Object >%s< not found in calibrated Latex table!\n", name1);
}

fclose(fp_latex_table);
return(status);
}
/***************************************************************************
* Read data from calibrated Latex table as generated by latex_calib.c:
* Example 
* 18384+0850 & HU 18 & 115 & 2007.690 & R & 20 & 0.483 & 0.013 & 128.1 & 0.4 & 1 &   \\
***************************************************************************/
int read_measures_from_line_of_Latex_table(char *line_buffer, float *epoch, 
                                           float *rho, float *err_rho,
                                           float *theta, float *err_theta)
{
char buffer[120];
int status;

*epoch = 0.; *rho = 0.; *err_rho = 0.; 
*theta = 0.; *err_theta = 0.;

/* Read epoch in column 4: */
status = latex_get_column_item(line_buffer, buffer, 4);
  if(status || (sscanf(buffer,"%f", epoch) != 1)) {
  fprintf(stderr,"Error reading epoch: %s\n", line_buffer);
  return(-1); 
  } 
/* Read rho in column 7: */
status = latex_get_column_item(line_buffer, buffer, 7);
  if(status || (sscanf(buffer,"%f", rho) != 1)) {
  fprintf(stderr,"Error reading rho: %s\n", line_buffer);
  return(-1); 
  }
/* Read err_rho in column 8: */
status = latex_get_column_item(line_buffer, buffer, 8);
  if(status || (sscanf(buffer,"%f", err_rho) != 1)) {
  fprintf(stderr,"Error reading err_rho: %s\n", line_buffer);
  return(-1); 
  }
/* Read theta in column 9: */
status = latex_get_column_item(line_buffer, buffer, 9);
  if(status || (sscanf(buffer,"%f", theta) != 1)) {
  fprintf(stderr,"Error reading theta: %s\n", line_buffer);
  return(-1); 
  } 
/* Read err_theta in column 10: */
status = latex_get_column_item(line_buffer, buffer, 10);
  if(status || (sscanf(buffer,"%f", err_theta) != 1)) {
  fprintf(stderr,"Error reading err_theta: %s\n", line_buffer);
  return(-1); 
  } 
return(0);
} 
/************************************************************
* Get character string in the icol th column of a LaTeX table
*
* INPUT:
*  line_buffer: string corresponding to a full line of a Latex table
*  icol: column number
*
* OUTPUT:
*  item: character string corresponding to the column #icol
* 
************************************************************/
int latex_get_column_item(char *line_buffer, char *item, int icol)
{
int ic;
char *pc, buffer[300];
 pc = line_buffer;

/* Get to the icol th column: */
 ic = 1;
 while(ic != icol) {
   while(*pc && *pc != '&') pc++; 
    if(*pc == '&') {
      pc++;
      ic++;
     } else {
     return(-1);
     }
 }

/* Icol has been reached: */
 strcpy(buffer, pc);
 pc = buffer;
/* Go to the next column : */
 while(*pc && *pc != '&') pc++; 
 *pc = '\0';
 strcpy(item, buffer);

return(0);
}
